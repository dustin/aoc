-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/dustin/aoc#readme</a>
@package aoc
@version 0.2.0.0


-- | Common stuff across AoC solutions.
module Advent.AoC

-- | A Megaparsec Parser.
type Parser = Parsec Void Text

-- | Load a file (e.g. "input/day24") with the given parser.
parseFile :: Parser a -> String -> IO a

-- | Parse a literal example.
parseLit :: Parser a -> Text -> a

-- | Parse a grid into ((x,y),a) pairs.
parseGrid :: (Char -> a) -> String -> [((Int, Int), a)]

-- | Two dimensional manhattan distance.
mdist2 :: (Int, Int) -> (Int, Int) -> Int

-- | Three dimensional manhattan distance.
mdist3 :: (Int, Int, Int) -> (Int, Int, Int) -> Int

-- | Four dimensional manhattan distance.
mdist4 :: (Int, Int, Int, Int) -> (Int, Int, Int, Int) -> Int
fst3 :: (a, b, c) -> a
snd3 :: (a, b, c) -> b
thrd :: (a, b, c) -> c

-- | Parallel application of a function across elements of a tuple.
zipt2 :: (a -> b -> c) -> (a, a) -> (b, b) -> (c, c)

-- | Parallel application of a function across elements of a tuple.
zipt3 :: (a -> b -> c) -> (a, a, a) -> (b, b, b) -> (c, c, c)

-- | Parallel application of a function across elements of a tuple.
zipt4 :: (a -> b -> c) -> (a, a, a, a) -> (b, b, b, b) -> (c, c, c, c)

-- | fmap for uniform tuples.
ftup :: (a -> b) -> (a, a) -> (b, b)

-- | fmap for uniform tuples
ftup3 :: (a -> b) -> (a, a, a) -> (b, b, b)

-- | fmap for uniform tuples
ftup4 :: (a -> b) -> (a, a, a, a) -> (b, b, b, b)

-- | zipWith, but along a two-dimensional input.
zipWith2D :: (x -> y -> a -> r) -> [x] -> [y] -> [[a]] -> [r]

-- | A circular succ
succ' :: (Bounded a, Enum a, Eq a) => a -> a

-- | A circular pred
pred' :: (Bounded a, Enum a, Eq a) => a -> a

-- | Repeat an operation n times.
ntimes :: Int -> (a -> a) -> a -> a

-- | Iterate until Nothing and then return the last Just value.
final :: (a -> Maybe a) -> a -> a

-- | expand a list to all of the variants of the list with an element
--   removed.
--   
--   <pre>
--   select "cat"  -&gt;  [('c',"at"),('a',"ct"),('t',"ca")]
--   </pre>
select :: [a] -> [(a, [a])]

-- | Löb's theorem.
--   <a>https://en.wikipedia.org/wiki/L%C3%B6b%27s_theorem</a>
--   <a>https://github.com/quchen/articles/blob/master/loeb-moeb.md</a>
möb :: (((a -> b) -> b) -> c -> a) -> c -> a

-- | Löb's theorem.
--   <a>https://en.wikipedia.org/wiki/L%C3%B6b%27s_theorem</a>
--   <a>https://github.com/quchen/articles/blob/master/loeb-moeb.md</a>
löb :: Functor f => f (f a -> a) -> f a


-- | A Set-type structure that stores values as bits in a bitmap.
module Advent.BitSet
data BitSet i w
BitSet :: !(i, i) -> !w -> BitSet i w
bitSet :: (Bits w, Ix i) => (i, i) -> BitSet i w
insert :: (Bits w, Ix i) => i -> BitSet i w -> BitSet i w
null :: Bits w => BitSet i w -> Bool
length :: Bits w => BitSet i w -> Int
member :: (Bits w, Ix i) => i -> BitSet i w -> Bool
notMember :: (Bits w, Ix i) => i -> BitSet i w -> Bool
delete :: (Bits w, Ix i) => i -> BitSet i w -> BitSet i w
isSubsetOf :: Bits w => BitSet i w -> BitSet i w -> Bool
union :: Bits w => BitSet i w -> BitSet i w -> BitSet i w
intersection :: Bits w => BitSet i w -> BitSet i w -> BitSet i w
difference :: Bits w => BitSet i w -> BitSet i w -> BitSet i w
disjoint :: Bits w => BitSet i w -> BitSet i w -> Bool
toList :: (Bits w, Ix i) => BitSet i w -> [i]
fromList :: (Bits w, Ix i) => (i, i) -> [i] -> BitSet i w
filter :: (Bits w, Ix i) => (i -> Bool) -> BitSet i w -> BitSet i w
findMin :: (Bits w, Ix i) => BitSet i w -> i
instance GHC.Classes.Eq w => GHC.Classes.Eq (Advent.BitSet.BitSet i w)
instance GHC.Classes.Ord w => GHC.Classes.Ord (Advent.BitSet.BitSet i w)
instance Control.DeepSeq.NFData (Advent.BitSet.BitSet i w)
instance Data.Bits.Bits w => GHC.Base.Semigroup (Advent.BitSet.BitSet i w)
instance (Data.Bits.Bits w, GHC.Show.Show i, GHC.Ix.Ix i) => GHC.Show.Show (Advent.BitSet.BitSet i w)


-- | A simple queue.
module Advent.Queue
data Queue a
Queue :: [a] -> [a] -> Queue a
fromList :: [a] -> Queue a
snoc :: a -> Queue a -> Queue a
head :: Queue a -> a
appendList :: Queue a -> [a] -> Queue a
pattern Empty :: Queue a
pattern (:<|) :: a -> Queue a -> Queue a
pop :: Queue a -> Maybe (a, Queue a)
singleton :: a -> Queue a
instance GHC.Show.Show a => GHC.Show.Show (Advent.Queue.Queue a)
instance GHC.Base.Semigroup (Advent.Queue.Queue a)
instance GHC.Base.Monoid (Advent.Queue.Queue a)
instance Data.Foldable.Foldable Advent.Queue.Queue


-- | Things I use for searching space in AoC.
module Advent.Search

-- | <a>dijkstra'</a> uses <a>Dijkstra's Algorithm</a> to find the costs
--   and links from a starting point to various points on a graph.
--   
--   See <a>resolveDijkstra</a> for a means of determining a path from the
--   resulting values.
dijkstra' :: Ord v => (v -> [(Int, v)]) -> v -> (v -> Bool) -> (v, Map v Int, Map v v)

-- | <a>dijkstra</a> uses <a>Dijkstra's Algorithm</a> to find the lowest
--   cost path to a given destination.
dijkstra :: Ord v => (v -> [(Int, v)]) -> v -> (v -> Bool) -> Maybe (Int, [v])

-- | Using maps computed by <a>dijkstra'</a>, find the cost and path from
--   the start to a destination.
resolveDijkstra :: Ord v => Map v Int -> Map v v -> v -> v -> Maybe (Int, [v])

-- | bfs finds all reachable states from a given value and a function to
--   find its neighbors.
bfs :: Ord a => (a -> [a]) -> a -> [a]

-- | bfsOn finds all reachable states from a given value and a function to
--   find its neighbors using a representative function.
--   
--   The representative function allows a separation between the structure
--   of a state and how it's represented, removing the Ord requirement for
--   the state.
bfsOn :: Ord r => (a -> r) -> (a -> [a]) -> a -> [a]

-- | bfsOnInt finds all reachable states from a given value and a function
--   to find its neighbors using a representative function.
--   
--   This is a specialization of bfsOn where the representation is an Int.
bfsOnInt :: (a -> Int) -> (a -> [a]) -> a -> [a]

-- | bfsM finds all reachable states from a given value and a function to
--   find its neighbors.
bfsM :: (Monad m, Ord a) => (a -> m [a]) -> a -> m [a]

-- | bfsOn finds all reachable states from a given value and a function to
--   find its neighbors using a representative function.
--   
--   The representative function allows a separation between the structure
--   of a state and how it's represented, removing the Ord requirement for
--   the state.
bfsOnM :: (Monad m, Ord r) => (a -> r) -> (a -> m [a]) -> a -> m [a]

-- | <a>binSearch</a> performs a binary search to find the boundary
--   function where a function returns its highest <a>LT</a> value.
binSearch :: Integral a => (a -> Ordering) -> a -> a -> a

-- | A binary search with auto-discovering bounds.
autoBinSearch :: Integral a => (a -> Ordering) -> a

-- | <a>binSearchM</a> performs a binary search over a monadic action to
--   find the boundary function where a function returns its highest
--   <a>LT</a> value.
binSearchM :: (Integral a, Monad m) => (a -> m Ordering) -> a -> a -> m a

-- | Get the position of the start of the first cycle and the cycle length
--   from a list.
findCycle :: Ord b => (a -> b) -> [a] -> (Int, Int, a)

-- | Get the first repeated element.
findRepeated :: Eq a => [a] -> Maybe a

-- | Get the first repeated element using a comparator function
findRepeatedOn :: Eq b => (a -> b) -> [a] -> Maybe a

-- | Find a local minimum.
findMin :: Ord b => (a -> b) -> [a] -> a

-- | Find a local maximum.
findMax :: Ord b => (a -> b) -> [a] -> a

-- | Count the number of items for which this is true.
countIf :: (a -> Bool) -> [a] -> Int

-- | Find an arrangement of <tt>a</tt> such that our predicate is happy for
--   each element in <tt>b</tt>.
--   
--   e.g.
--   
--   <pre>
--   &gt;&gt;&gt; arranger (&lt;) [1,3,2,4] [3,6,2,6]
--   Just [2, 3, 1, 4]
--   </pre>
arranger :: (a -> b -> Bool) -> [a] -> [b] -> Maybe [a]

-- | Make variations of a list by changing an element.
perturb :: (a -> [a]) -> [a] -> [[a]]


-- | Functions for working in 2D space.
module Advent.TwoD

-- | A point in 2D space.
type Point = (Int, Int)

-- | Get the points around a point (not including diagonals).
around :: Point -> [Point]

-- | Get the points around a point (including diagonals).
aroundD :: Point -> [Point]

-- | Directions.
data Dir
N :: Dir
E :: Dir
S :: Dir
W :: Dir

-- | Move a point one position in a particular direction.
fwd :: Dir -> Point -> Point

-- | Move a point some amount in a particular direction.
fwdBy :: Int -> Dir -> Point -> Point

-- | Add some to points.
addPoint :: (Int, Int) -> Point -> Point

-- | Multiply x and y values in a point by the given amounts.
mulPoint :: (Int, Int) -> Point -> Point
instance GHC.Classes.Eq Advent.TwoD.Dir
instance GHC.Enum.Enum Advent.TwoD.Dir
instance GHC.Enum.Bounded Advent.TwoD.Dir
instance GHC.Show.Show Advent.TwoD.Dir


-- | Various things to help visualize data.
module Advent.Vis
white :: PixelRGB8
black :: PixelRGB8
red :: PixelRGB8
green :: PixelRGB8
blue :: PixelRGB8
someColors :: [PixelRGB8]
class Bounded2D a
bounds2d :: Bounded2D a => a -> ((Int, Int), (Int, Int))
type PixelFun = (Int, Int) -> PixelRGB8
mapPixelFun :: Map (Int, Int) a -> (a -> PixelRGB8) -> PixelFun
mapPixelFunTrans :: Ord a => Map (Int, Int) a -> [(a, PixelRGB8)] -> PixelFun
listBounds :: Integral a => [(a, a)] -> ((Int, Int), (Int, Int))
data DrawSpec
DrawSpec :: Int -> Int -> (Int -> Int) -> (Int -> Int) -> (Int -> Int) -> (Int -> Int) -> DrawSpec
[width] :: DrawSpec -> Int
[height] :: DrawSpec -> Int
[transX] :: DrawSpec -> Int -> Int
[transY] :: DrawSpec -> Int -> Int
[invTransX] :: DrawSpec -> Int -> Int
[invTransY] :: DrawSpec -> Int -> Int
mkDrawSpec :: Bounded2D a => a -> DrawSpec
draw :: Bounded2D a => FilePath -> a -> PixelFun -> IO ()
type CharFun = (Int, Int) -> Char
mapCharFun :: Map (Int, Int) a -> (a -> Char) -> CharFun
mapCharFunTrans :: Ord a => Map (Int, Int) a -> [(a, Char)] -> CharFun
drawString :: Bounded2D a => a -> CharFun -> String
withHiddenCursor :: IO a -> IO a
drawingBracket :: IO a -> IO a
instance GHC.Show.Show Advent.Vis.DrawSpec
instance GHC.Real.Integral a => Advent.Vis.Bounded2D (Data.Map.Internal.Map (a, a) b)
