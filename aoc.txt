-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/dustin/aoc#readme</a>
@package aoc
@version 0.1.0.0


-- | Common stuff across AoC solutions.
module Advent.AoC

-- | A Megaparsec Parser.
type Parser = Parsec Void Text

-- | Load a file (e.g. "input/day24") with the given parser.
parseFile :: Parser a -> String -> IO a

-- | Parse a literal example.
parseLit :: Parser a -> Text -> a

-- | Parse a grid into a map of (x,y) pairs.
parseGrid :: (Char -> a) -> String -> Map (Int, Int) a

-- | Two dimensional manhattan distance.
mdist2 :: (Int, Int) -> (Int, Int) -> Int

-- | Three dimensional manhattan distance.
mdist3 :: (Int, Int, Int) -> (Int, Int, Int) -> Int

-- | Four dimensional manhattan distance.
mdist4 :: (Int, Int, Int, Int) -> (Int, Int, Int, Int) -> Int

-- | Parallel application of a function across elements of a tuple.
zipt2 :: (a -> b -> c) -> (a, a) -> (b, b) -> (c, c)

-- | Parallel application of a function across elements of a tuple.
zipt3 :: (a -> b -> c) -> (a, a, a) -> (b, b, b) -> (c, c, c)

-- | Parallel application of a function across elements of a tuple.
zipt4 :: (a -> b -> c) -> (a, a, a, a) -> (b, b, b, b) -> (c, c, c, c)

-- | A circular succ
succ' :: (Bounded a, Enum a, Eq a) => a -> a

-- | A circular pred
pred' :: (Bounded a, Enum a, Eq a) => a -> a
fst3 :: (a, b, c) -> a
snd3 :: (a, b, c) -> b
thrd :: (a, b, c) -> c

-- | expand a list to all of the variants of the list with an element
--   removed.
--   
--   <pre>
--   select "cat"  -&gt;  [('c',"at"),('a',"ct"),('t',"ca")]
--   </pre>
select :: [a] -> [(a, [a])]

module Advent.BitSet
data BitSet i w
BitSet :: !(i, i) -> !w -> BitSet i w
bitSet :: (Bits w, Ix i) => (i, i) -> BitSet i w
insert :: (Bits w, Ix i) => i -> BitSet i w -> BitSet i w
null :: Bits w => BitSet i w -> Bool
length :: Bits w => BitSet i w -> Int
member :: (Bits w, Ix i) => i -> BitSet i w -> Bool
notMember :: (Bits w, Ix i) => i -> BitSet i w -> Bool
delete :: (Bits w, Ix i) => i -> BitSet i w -> BitSet i w
isSubsetOf :: Bits w => BitSet i w -> BitSet i w -> Bool
union :: Bits w => BitSet i w -> BitSet i w -> BitSet i w
intersection :: Bits w => BitSet i w -> BitSet i w -> BitSet i w
difference :: Bits w => BitSet i w -> BitSet i w -> BitSet i w
disjoint :: Bits w => BitSet i w -> BitSet i w -> Bool
toList :: (Bits w, Ix i) => BitSet i w -> [i]
fromList :: (Bits w, Ix i) => (i, i) -> [i] -> BitSet i w
filter :: (Bits w, Ix i) => (i -> Bool) -> BitSet i w -> BitSet i w
findMin :: (Bits w, Ix i) => BitSet i w -> i
instance GHC.Classes.Eq w => GHC.Classes.Eq (Advent.BitSet.BitSet i w)
instance GHC.Classes.Ord w => GHC.Classes.Ord (Advent.BitSet.BitSet i w)
instance Control.DeepSeq.NFData (Advent.BitSet.BitSet i w)
instance Data.Bits.Bits w => GHC.Base.Semigroup (Advent.BitSet.BitSet i w)
instance (Data.Bits.Bits w, GHC.Show.Show i, GHC.Arr.Ix i) => GHC.Show.Show (Advent.BitSet.BitSet i w)

module Advent.Queue
data Queue a
Queue :: [a] -> [a] -> Queue a
fromList :: [a] -> Queue a
snoc :: a -> Queue a -> Queue a
head :: Queue a -> a
appendList :: Queue a -> [a] -> Queue a
pattern Empty :: Queue a
pattern (:<|) :: a -> Queue a -> Queue a
pop :: Queue a -> Maybe (a, Queue a)
singleton :: a -> Queue a
instance GHC.Show.Show a => GHC.Show.Show (Advent.Queue.Queue a)
instance GHC.Base.Semigroup (Advent.Queue.Queue a)
instance GHC.Base.Monoid (Advent.Queue.Queue a)
instance Data.Foldable.Foldable Advent.Queue.Queue


-- | Things I use for searching space in AoC.
module Advent.Search

-- | <a>dijkstra'</a> uses <a>Dijkstra's Algorithm</a> to find the costs
--   and links from a starting point to various points on a graph.
--   
--   See <a>resolveDijkstra</a> for a means of determining a path from the
--   resulting values.
dijkstra' :: Ord v => (v -> [(Int, v)]) -> v -> (v -> Bool) -> (v, Map v Int, Map v v)

-- | <tt>dijkstra''</tt> uses <a>Dijkstra's Algorithm</a> to find the
--   lowest cost path to a given destination.
dijkstra :: Ord v => (v -> [(Int, v)]) -> v -> (v -> Bool) -> Maybe (Int, [v])

-- | Using maps computed by <a>dijkstra'</a>, find the cost and path from
--   the start to a destination.
resolveDijkstra :: Ord v => Map v Int -> Map v v -> v -> v -> Maybe (Int, [v])

-- | <a>binSearch</a> performs a binary search to find the boundary
--   function where a function returns its highest <a>LT</a> value.
binSearch :: Integral a => (a -> Ordering) -> a -> a -> a

-- | A binary search with auto-discovering bounds.
autoBinSearch :: Integral a => (a -> Ordering) -> a

-- | <a>binSearchM</a> performs a binary search over a monadic action to
--   find the boundary function where a function returns its highest
--   <a>LT</a> value.
binSearchM :: (Integral a, Monad m) => (a -> m Ordering) -> a -> a -> m a

-- | Get the position of the start of the first cycle and the cycle length
--   from a list.
findCycle :: Ord b => (a -> b) -> [a] -> (Int, Int, a)

-- | Get the first repeated element.
findRepeated :: Eq a => [a] -> Maybe a

-- | Get the first repeated element using a comparator function
findRepeatedOn :: Eq b => (a -> b) -> [a] -> Maybe a

-- | Find a local minimum.
findMin :: Ord b => (a -> b) -> [a] -> a

-- | Find a local maximum.
findMax :: Ord b => (a -> b) -> [a] -> a

-- | bfs finds all reachable states from a given value and a function to
--   find its neighbors.
bfs :: Ord a => (a -> [a]) -> a -> [a]

-- | bfsOn finds all reachable states from a given value and a function to
--   find its neighbors using a representative function.
--   
--   The representative function allows a separation between the structure
--   of a state and how it's represented, removing the Ord requirement for
--   the state.
bfsOn :: Ord r => (a -> r) -> (a -> [a]) -> a -> [a]

-- | Count the number of items for which this is true.
countIf :: (a -> Bool) -> [a] -> Int

-- | Make variations of a list by changing an element.
perturb :: (a -> [a]) -> [a] -> [[a]]

module Advent.TwoD
type Point = (Int, Int)
around :: Point -> [Point]
aroundD :: Point -> [Point]
data Dir
N :: Dir
E :: Dir
S :: Dir
W :: Dir
fwd :: Dir -> (Int, Int) -> (Int, Int)
instance GHC.Classes.Eq Advent.TwoD.Dir
instance GHC.Enum.Enum Advent.TwoD.Dir
instance GHC.Enum.Bounded Advent.TwoD.Dir
instance GHC.Show.Show Advent.TwoD.Dir

module Advent.Vis
white :: PixelRGB8
black :: PixelRGB8
red :: PixelRGB8
green :: PixelRGB8
blue :: PixelRGB8
someColors :: [PixelRGB8]
class Bounded2D a
bounds2d :: Bounded2D a => a -> ((Int, Int), (Int, Int))
type PixelFun = (Int, Int) -> PixelRGB8
mapPixelFun :: Map (Int, Int) a -> (a -> PixelRGB8) -> PixelFun
mapPixelFunTrans :: Ord a => Map (Int, Int) a -> [(a, PixelRGB8)] -> PixelFun
listBounds :: Integral a => [(a, a)] -> ((Int, Int), (Int, Int))
data DrawSpec
DrawSpec :: Int -> Int -> (Int -> Int) -> (Int -> Int) -> (Int -> Int) -> (Int -> Int) -> DrawSpec
[width] :: DrawSpec -> Int
[height] :: DrawSpec -> Int
[transX] :: DrawSpec -> Int -> Int
[transY] :: DrawSpec -> Int -> Int
[invTransX] :: DrawSpec -> Int -> Int
[invTransY] :: DrawSpec -> Int -> Int
mkDrawSpec :: Bounded2D a => a -> DrawSpec
draw :: Bounded2D a => FilePath -> a -> PixelFun -> IO ()
type CharFun = (Int, Int) -> Char
mapCharFun :: Map (Int, Int) a -> (a -> Char) -> CharFun
mapCharFunTrans :: Ord a => Map (Int, Int) a -> [(a, Char)] -> CharFun
drawString :: Bounded2D a => a -> CharFun -> String
withHiddenCursor :: IO a -> IO a
drawingBracket :: IO a -> IO a
instance GHC.Show.Show Advent.Vis.DrawSpec
instance GHC.Real.Integral a => Advent.Vis.Bounded2D (Data.Map.Internal.Map (a, a) b)
